/*
    handshaking.c 
    Created on: oct 3, 2024
    Author : Abdelrahman Ibrahim

*/

#include"handshaking.h"


/*
   * 1- client hello : tls version  , cryptoAlgo(RSA and AES) , random variables and hashing
   * 2- server hello : cryptoAgrement , session id and server's digital signature (hash the message then encrypt using private key)
   * 3- client check server's digital signature using server's public key
   * 4- key generation
   * 5- finish message from server and client
*/

uint32_t global_n , global_e , global_d;


void clientHello(client_hello_t * client_hello_mes){
    /*this printf function will be replaced by the communication 
    protocol interface using in TLS*/
    PRNG  randonSeeds;
    init_prng(&randonSeeds , CLIENT_INIT_SEED);
    /*generate rondom numbers to be exchanged between server and client*/
    for(uint8_t i = 0 ; i < 16 ; i++){
        client_hello_mes->client_random[i] = (uint8_t)next_prng(&randonSeeds , MODULO_32); 
    }
    for(uint8_t i = 0 ; i < 16 ; i++){
        printf("%x ",client_hello_mes->client_random[i]);
    }
    printf("\nsession ID = %d\n",client_hello_mes->sessionID);
}

void servevrHello(uint8_t * serverMessage ,signature_message_server_t  * server_hello_mes){
    uint64_t tempHash[32];
    uint8_t hashed_sever_message[32];
    for(uint8_t i = 0 ; i < 16 ; i++){
        server_hello_mes->server_hello_message[i] = serverMessage[i];
    }
    PRNG  randonSeeds;
    init_prng(&randonSeeds , SERVER_INIT_SEED);
    /*generate rondom numbers to be exchanged between server and client*/
    for(uint8_t i = 0 ; i < 16 ; i++){
        server_hello_mes->server_random[i] = (uint8_t)next_prng(&randonSeeds , MODULO_32); 
    }
    for(uint8_t i = 0 ; i < 16 ; i++){
        printf("%x ",server_hello_mes->server_random[i]);
    }
    /*calculate the hash of the message*/
    sha256_block sha_block;
    sha256_init(&sha_block);
    sha256_update(&sha_block, (BYTE *)server_hello_mes->server_hello_message, 16);
    sha256_final(&sha_block, hashed_sever_message);
    for(uint8_t i = 0 ; i < 32 ; i++){
        tempHash[i] = hashed_sever_message[i];
    }

   /* encrypt the hash using RSA with private key*/
    uint32_t  e , n  , d;
    generate_key(&e , &n);
    generatePrivateKey(e , &d);
    global_e = e; //public key of server
    global_n = n;
    global_d = d;
    rsaEncryption(server_hello_mes->encrypted_hashed_message ,  tempHash , d , n); //encrypt with the private key
}

uint8_t clientCheckDigitalSignature(signature_message_server_t * server_message ,signature_message_client_t * client_message){
    /*decrypt hash message with server public key and get the hash (suppose validation authority accept the puplic key)
    * calculate the hash of server message
    * compare the hashed value that decrypt with calculated one
    *  if the same value return 1 if not return 0
    */
    uint8_t hashed_sever_message[32] , tempHashed[32];
    uint8_t flag = 1;
    rsadecryption(server_message->encrypted_hashed_message , client_message->decrypted_hashed_message , global_e , global_n);
    for(uint8_t i = 0 ; i < 32 ; i++){
        tempHashed[i] = client_message->decrypted_hashed_message[i];
    }
    sha256_block sha_block;
    sha256_init(&sha_block);
    sha256_update(&sha_block , (BYTE *)server_message->server_hello_message , 16);
    sha256_final(&sha_block , hashed_sever_message);
    /*compare between decrypted hash and calculated hash*/
    for(uint8_t i = 0 ; i <32 ; i++){
        if(hashed_sever_message[i] != tempHashed[i]) flag = 0;
    }
    return flag;
}


/*generated by the client*/
void generatePreMasterKey(uint8_t pre_master_key[48]){
    /*firstly genrate 48 random Bytes*/
    uint64_t random_pre_master_key[48];
    uint64_t encrypted_pre_master_key[48];
    PRNG  randonSeeds;
    init_prng(&randonSeeds , PRE_MASTER_SEED);
    /*generate rondom numbers to be exchanged between server and client*/
    for(uint8_t i = 0 ; i < 48 ; i++){
        random_pre_master_key[i] = (uint8_t)next_prng(&randonSeeds , MODULO_32); 
    }
    printf("\npre master key : \n");
    for(uint8_t i = 0 ; i < 48 ; i++){
        printf("%x ",random_pre_master_key[i]);
    }
    /*encrypt the pre master key using server's public key*/
    rsaEncryption(encrypted_pre_master_key , random_pre_master_key , global_e , global_n);
    for(uint8_t i = 0 ; i < 48 ; i++){
        pre_master_key[i] = (uint8_t)encrypted_pre_master_key[i];
    }
    printf("\nencrypted pre master key : \n");
    for(uint8_t i = 0 ; i < 48 ; i++){
        printf("%x ",pre_master_key[i]);
    }
}


void generateMasterKey(uint8_t pre_master_key[48] , uint8_t random_key[16] , uint8_t master_key[HMAC_BLOCK_SIZE]){
    /*get a random key from random keys generated in the handshaking*/
    /*make HMAC using random data and pre master key to generate the master key*/
    hmac(master_key , pre_master_key , 48 , random_key , 16);
    printf("\nmaster key : \n");
    for(uint8_t i = 0 ; i < 32 ; i++){
        printf("%x ",master_key[i]);
    }
}